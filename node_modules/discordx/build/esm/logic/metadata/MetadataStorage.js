import { DIService } from "@discordx/di";
import { Modifier } from "@discordx/internal";
import _ from "lodash";
import { ComponentType, DApplicationCommand, DApplicationCommandOption, DComponent, DOn, DSimpleCommand, } from "../../index.js";
/**
 * @category Internal
 */
export class MetadataStorage {
    // internal
    static _isBuilt = false;
    static _instance;
    _guards = [];
    _discords = [];
    _modifiers = [];
    // events
    _events = [];
    // custom Handlers
    _buttonComponents = [];
    _selectMenuComponents = [];
    // simple command
    _simpleCommands = [];
    _simpleCommandsByName = [];
    _simpleCommandsByPrefix = new Map();
    _simpleCommandOptions = [];
    // discord commands
    _applicationCommandSlashes = [];
    _applicationCommandSlashesFlat = [];
    _applicationCommandUsers = [];
    _applicationCommandMessages = [];
    _applicationCommandSlashOptions = [];
    // groups
    _applicationCommandSlashGroups = [];
    _applicationCommandSlashSubGroups = [];
    // static getters
    static clear() {
        this._instance = new MetadataStorage();
    }
    static get isBuilt() {
        return this._isBuilt;
    }
    static get instance() {
        if (!this._instance) {
            this._instance = new MetadataStorage();
        }
        return this._instance;
    }
    static set instance(value) {
        this._instance = value;
    }
    // getters
    get isBuilt() {
        return MetadataStorage._isBuilt;
    }
    get events() {
        return this._events;
    }
    /**
     * Get the list of used events without duplications
     */
    get usedEvents() {
        return this.events.reduce((prev, event, index) => {
            const found = this.events.find((event2) => event.event === event2.event);
            const foundIndex = found ? this.events.indexOf(found) : -1;
            if (foundIndex === index || found?.once !== event.once) {
                prev.push(event);
            }
            return prev;
        }, []);
    }
    get discords() {
        return this._discords;
    }
    get applicationCommandSlashes() {
        return this._applicationCommandSlashes;
    }
    get applicationCommandSlashesFlat() {
        return this._applicationCommandSlashesFlat;
    }
    get applicationCommandSlashOptions() {
        return this._applicationCommandSlashOptions;
    }
    get applicationCommandSlashGroups() {
        return this._applicationCommandSlashGroups;
    }
    get applicationCommandSlashSubGroups() {
        return this._applicationCommandSlashSubGroups;
    }
    get applicationCommandUsers() {
        return this._applicationCommandUsers;
    }
    get applicationCommandMessages() {
        return this._applicationCommandMessages;
    }
    get applicationCommands() {
        return [
            ...this.applicationCommandSlashes,
            ...this.applicationCommandMessages,
            ...this.applicationCommandUsers,
        ];
    }
    get simpleCommandsByName() {
        return this._simpleCommandsByName;
    }
    get simpleCommandsByPrefix() {
        return this._simpleCommandsByPrefix;
    }
    get simpleCommands() {
        return this._simpleCommands;
    }
    get buttonComponents() {
        return this._buttonComponents;
    }
    get selectMenuComponents() {
        return this._selectMenuComponents;
    }
    get discordMembers() {
        return [
            ...this._applicationCommandSlashes,
            ...this._applicationCommandUsers,
            ...this._applicationCommandMessages,
            ...this._simpleCommands,
            ...this._events,
            ...this._buttonComponents,
            ...this._selectMenuComponents,
        ];
    }
    addModifier(modifier) {
        this._modifiers.push(modifier);
    }
    addOn(on) {
        this._events.push(on);
    }
    addApplicationCommandSlash(slash) {
        this._applicationCommandSlashes.push(slash);
    }
    addApplicationCommandUser(slash) {
        this._applicationCommandUsers.push(slash);
    }
    addApplicationCommandMessage(slash) {
        this._applicationCommandMessages.push(slash);
    }
    addApplicationCommandSlashOption(option) {
        this._applicationCommandSlashOptions.push(option);
    }
    addApplicationCommandSlashGroups(group) {
        this._applicationCommandSlashGroups.push(group);
    }
    addApplicationCommandSlashSubGroups(subGroup) {
        this._applicationCommandSlashSubGroups.push(subGroup);
    }
    addSimpleCommand(cmd) {
        this._simpleCommands.push(cmd);
    }
    addSimpleCommandOption(cmdOption) {
        this._simpleCommandOptions.push(cmdOption);
    }
    addComponentButton(button) {
        this._buttonComponents.push(button);
    }
    addComponentSelectMenu(selectMenu) {
        this._selectMenuComponents.push(selectMenu);
    }
    addGuard(guard) {
        this._guards.push(guard);
        DIService.instance.addService(guard.classRef);
    }
    addDiscord(discord) {
        this._discords.push(discord);
        DIService.instance.addService(discord.classRef);
    }
    async build() {
        // build the instance if not already built
        if (MetadataStorage.isBuilt) {
            return;
        }
        MetadataStorage._isBuilt = true;
        // Link the events with @Discord class instances
        this.discordMembers.forEach((member) => {
            // Find the linked @Discord of an event
            const discord = this._discords.find((instance) => {
                return instance.from === member.from;
            });
            if (!discord) {
                throw Error(`Did you forget to use the @discord decorator on your class: ${member.from.name}\n` +
                    "read more at https://discord-ts.js.org/docs/decorators/general/discord\n\n");
            }
            // You can get the @Discord that wrap a @SimpleCommand/@On by using
            // on.discord or slash.discord
            member.discord = discord;
            if (member instanceof DApplicationCommand) {
                discord.applicationCommands.push(member);
            }
            if (member instanceof DSimpleCommand) {
                discord.simpleCommands.push(member);
            }
            if (member instanceof DOn) {
                discord.events.push(member);
            }
            if (member instanceof DComponent) {
                if (member.type === ComponentType.Button) {
                    discord.buttons.push(member);
                }
                else if (member.type === ComponentType.SelectMenu) {
                    discord.selectMenus.push(member);
                }
            }
        });
        await Modifier.applyFromModifierListToList(this._modifiers, this._discords);
        await Modifier.applyFromModifierListToList(this._modifiers, this._events);
        await Modifier.applyFromModifierListToList(this._modifiers, this._applicationCommandSlashes);
        await Modifier.applyFromModifierListToList(this._modifiers, this._applicationCommandSlashOptions);
        await Modifier.applyFromModifierListToList(this._modifiers, this._applicationCommandMessages);
        await Modifier.applyFromModifierListToList(this._modifiers, this._applicationCommandUsers);
        await Modifier.applyFromModifierListToList(this._modifiers, this._simpleCommands);
        await Modifier.applyFromModifierListToList(this._modifiers, this._simpleCommandOptions);
        await Modifier.applyFromModifierListToList(this._modifiers, this._buttonComponents);
        await Modifier.applyFromModifierListToList(this._modifiers, this._selectMenuComponents);
        this._applicationCommandSlashesFlat = this._applicationCommandSlashes;
        this._applicationCommandSlashes = this.groupSlashes();
        this.buildSimpleCommands();
    }
    buildSimpleCommands() {
        this._simpleCommands.forEach((cmd) => {
            // Separately map special prefix commands
            if (cmd.prefix) {
                [...cmd.prefix].forEach((pfx) => {
                    const commands = this._simpleCommandsByPrefix.get(pfx) ?? [];
                    const mapCmd = [
                        { command: cmd, name: cmd.name },
                    ];
                    cmd.aliases.forEach((al) => {
                        mapCmd.push({ command: cmd, name: al });
                    });
                    mapCmd.forEach((mapCommand) => {
                        if (_.findIndex(commands, { name: mapCommand.name }) !== -1) {
                            throw Error(`Duplicate simple command name: ${mapCommand.name} (of: ${mapCommand.command.name})`);
                        }
                    });
                    this._simpleCommandsByPrefix.set(pfx, [...commands, ...mapCmd].sort((a, b) => b.name.length - a.name.length));
                });
                return;
            }
            // To improve search performance, map all commands together
            if (_.findIndex(this._simpleCommandsByName, { name: cmd.name }) !== -1) {
                throw Error(`Duplicate simple command name: ${cmd.name}`);
            }
            this._simpleCommandsByName.push({ command: cmd, name: cmd.name });
            cmd.aliases.forEach((al) => {
                if (_.findIndex(this._simpleCommandsByName, { name: al }) !== -1) {
                    throw Error(`Duplicate simple command name: ${al} (alias of command: ${cmd.name})`);
                }
                this._simpleCommandsByName.push({ command: cmd, name: al });
            });
        });
        // sort simple commands
        this._simpleCommandsByName = this._simpleCommandsByName.sort(function (a, b) {
            // ASC  -> a.length - b.length
            // DESC -> b.length - a.length
            return b.name.length - a.name.length;
        });
    }
    groupSlashes() {
        const groupedSlashes = new Map();
        // Create Slashes from class groups that will wraps the commands
        //
        // "name": "permissions",
        // "description": "Get or edit permissions for a user or a role",
        // "options": [
        //    ...commands
        // ]
        //
        this._applicationCommandSlashGroups.forEach((group) => {
            const slashParent = DApplicationCommand.create(group.name, "CHAT_INPUT", group.infos?.description).decorate(group.classRef, group.key, group.method);
            const discord = this._discords.find((instance) => {
                return instance.from === slashParent.from;
            });
            if (!discord) {
                return;
            }
            slashParent.discord = discord;
            slashParent.guilds = [...slashParent.discord.guilds];
            slashParent.botIds = [...slashParent.discord.botIds];
            slashParent.permissions = [
                ...slashParent.permissions,
                ...slashParent.discord.permissions,
            ];
            slashParent.defaultPermission = slashParent.discord.defaultPermission;
            groupedSlashes.set(group.name, slashParent);
            const slashes = this._applicationCommandSlashes.filter((slash) => {
                return slash.group === slashParent.name && !slash.subgroup;
            });
            slashes.forEach((slash) => {
                slashParent.options.push(slash.toSubCommand());
            });
            this._applicationCommandSlashesFlat.forEach((slash) => {
                if (slash.group === slashParent.name) {
                    slash.defaultPermission = slashParent.defaultPermission;
                    slash.permissions = slashParent.permissions;
                    slash.guilds = slashParent.guilds;
                    slash.botIds = slashParent.botIds;
                }
            });
        });
        // Create for each subgroup (@SlashGroup on methods) create an SlashOption based on Slash
        //
        // "name": "permissions",
        // "description": "Get or edit permissions for a user or a role",
        // "options": [
        //    {
        //        "name": "user",
        //        "description": "Get or edit permissions for a user",
        //        "type": "SUB_COMMAND_GROUP"
        //        "options": [
        //            ....
        //        ]
        //     }
        // ]
        this._applicationCommandSlashSubGroups.forEach((subGroup) => {
            const option = DApplicationCommandOption.create(subGroup.name, undefined, undefined, subGroup.infos?.description, undefined, undefined, undefined, undefined, "SUB_COMMAND_GROUP").decorate(subGroup.classRef, subGroup.key, subGroup.method);
            // Get the slashes that are in this subgroup
            const slashes = this._applicationCommandSlashes.filter((slash) => {
                return slash.subgroup === option.name;
            });
            // Convert this slashes into options and add it to the option parent
            // this slashes are the node of the options
            //
            // "name": "permissions",
            // "description": "Get or edit permissions for a user or a role",
            // "options": [
            //     {
            //         "name": "user",
            //         "description": "Get or edit permissions for a user",
            //         "type": "SUB_COMMAND_GROUP"
            //         "options": [
            //             {
            //                 "name": "get",
            //                 "description": "Get permissions for a user",
            //                 "type": "SUB_COMMAND"
            //                 "options": [
            //                 ]
            //              }
            //          ]
            //      }
            // ]
            //
            slashes.forEach((slash) => {
                option.options.push(slash.toSubCommand());
            });
            // Get the first sub command to read root group name
            const groupSlash = slashes[0]?.group
                ? groupedSlashes.get(slashes[0].group)
                : undefined;
            if (groupSlash) {
                groupSlash.options.push(option);
            }
        });
        return [
            ...this._applicationCommandSlashes.filter((s) => !s.group && !s.subgroup),
            ...Array.from(groupedSlashes.values()),
        ];
    }
    /**
     * Trigger a discord event
     *
     * @param event - The event to trigger
     * @param client - The client instance
     * @param once - Execute event once
     */
    trigger(guards, event, client, once = false
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const responses = [];
        const eventsToExecute = this._events.filter((on) => {
            return on.event === event && on.once === once;
        });
        return async (...params) => {
            await Promise.all(eventsToExecute.map(async (on) => {
                const botIds = on.botIds;
                if (botIds.length && !botIds.includes(client.botId)) {
                    return;
                }
                const res = await on.execute(guards, params, client);
                responses.push(res);
            }));
            return responses;
        };
    }
}
//# sourceMappingURL=MetadataStorage.js.map